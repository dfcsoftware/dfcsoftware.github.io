<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Algol</title>
	<meta name="date" content="2025-10-17 10:20"/>
	<meta name="author" content="Don Cohoon"/>
	<meta name="summary" content="Algol was once described as a *disease* caught by unsuspecting people that can last for many years. I suppose it was that for me. I first caught it in 1980 and did not lose hold of it's grasp until 1993."/>
	<meta name="license" content="'[CC-BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)'"/>
<meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/linux-in-house/common.css" type="text/css" />
</head>
<body>

<p><a href="/linux-in-house/index.html"><h1>Linux in House</h1></a></p>

<link href="/linux-in-house/pagefind/pagefind-ui.css" rel="stylesheet">
<script src="/linux-in-house/pagefind/pagefind-ui.js"></script>

<div id="search"></div>
<script>
window.addEventListener('DOMContentLoaded', (event) => {
      new PagefindUI({ element: "#search", showSubResults: true });
});
</script>

<blockquote>
<p><a href="/linux-in-house/linux/welcome.html">Welcome Back My Friends</a></p>
</blockquote>

<h1 id="title">Algol</h1>

<p>Published: 2025-10-17 10:20 <br />
Author: Don Cohoon</p>

<hr />

<div class="TOC">

<ul>
<li><a href="#title">Algol</a></li>
<li><a href="#nightshift">Night Shift</a></li>
<li><a href="#educationbythebook">Education by the book</a></li>
<li><a href="#opensource">Open Source</a></li>
<li><a href="#otheralgolvariantsihaveused">Other Algol variants I have used</a></li>
<li><a href="#featuresilike">Features I like</a></li>
<li><a href="#conclusion">Conclusion</a>
<ul>
<li><a href="#regards">Regards,</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
<li><a href="#algolprogram">Algol Program</a>
<ul>
<li><a href="#sharedlibrarysitesupport">Shared Library Sitesupport</a>
<ul>
<li><a href="#madeforhumansbyahuman">Made for Humans, by a Human</a></li>
<li><a href="#links">Links</a></li>
<li><a href="#social">Social</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<hr />

<p>Algol was once described as a <em>disease</em> caught by unsuspecting people that can last for many years. I suppose it was that for me. I first caught it in 1980 and did not lose hold of it&#8217;s grasp until 1993.</p>

<p>It was my first really great discovery since my brother&#8217;s motorcycle became to old for him and was passed on to me, for $100. How fitting that seven years later my brother once again offered me a next level change in my life.</p>

<h1 id="nightshift">Night Shift</h1>

<p>&#8220;We just hired another idiot!&#8221; sighed my brother, followed by &#8220;you could do better than the new guy.&#8221;</p>

<p>&#8220;Well, give me a chance!&#8221; I offered right back, especially intrigued by the possibility.</p>

<p>That summer I was driving a delivery van in Dallas TX and we had just passed the 30 days over 100 degrees mark.</p>

<p>So, the afternoon shift started at 4:30 pm until after midnight, when I came on. Running batch jobs for the Hospital, printing out patient bills, accounting reports and checks. I loved it, it was interesting, a good work environment and best of all <strong>Air Conditioning</strong>.</p>

<p>I started noticing the Work Flow Language (WFL), source code would print out and some of the structure caught my eye. I gained access to a programmers terminal and started writing WFL code to calculate the conversion of a 60 minute clock to the paycheck 100 unit clock in order to see what my next paycheck could be. Then I started writing a Star Trek flying text program. Variables, loops, if and then, and saving all that newly created work to disk; was just Amazing to me.</p>

<p>Not more than a couple months later I started writing, compiling and running actual Algol code. The WFL job control language was a subset of Algol so it fit like a glove.</p>

<p>Then the manager of Technical Support asked me one day, &#8220;Guess who was the most active programmer last month?&#8221; Little did I know it was me. From then on I started delivering actual working code to help run the second and third shifts.</p>

<h1 id="educationbythebook">Education by the book</h1>

<p>Donald Gregory published several Algol textbooks and a technical journal. I bought up everything he had.</p>

<p>Plus in those days one of my tasks was to update the technical bookshelf with new changes. That involved opening every three ring binder, extracting the old pages and inserting new ones. But for me it was a chance to really read each and every manual. Another gift from my brother, &#8220;Just read the manuals. Almost no one else does so you&#8217;ll have an advantage.&#8221; Oh yes!</p>

<h1 id="opensource">Open Source</h1>

<p>In the 1980&#8217;s, Burroughs computers used Algol-based languages for everything, even the operating system (MCP) was written in NEWP.</p>

<blockquote>
<p>NEWP is a programming language based on ALGOL that enables you to implement system software. Its major application is the Master Control Program (MCP), and thus some features of NEWP are closely tied to the features available in the MCP and underlying hardware. <a href="https://public.support.unisys.com/aseries/docs/clearpath-mcp-20.0/88077144-024/section-000068088.html">https://public.support.unisys.com/aseries/docs/clearpath-mcp-20.0/88077144-024/section-000068088.html</a></p>
</blockquote>

<p>It seemed only logical that the source code for everything was included in each software release. It was also routine to <em>patch</em> the MCP for local requirements, and these patches were openly shared with magnetic tape at local, regional and national Cooperative Users of Burroughs Equipment (CUBE) conferences.</p>

<p>Eventually I submitted <em>patches</em> for a Message Control System (MCS) called COMS to the developers in Mission Viejo, California using magnetic tape from Florida.</p>

<h1 id="otheralgolvariantsihaveused">Other Algol variants I have used</h1>

<ul>
<li>DCAlgol: Data Communications extensions</li>
</ul>

<p>This is really useful for time-sharing a lot of users on terminals to the system. Command AND Edit (CANDE) was the first MCS, and is used by programmers. In the early years companies wrote their own MCS, until GEMCOS, and eventually COMS were released for application support, i.e. terminal &lt;-&gt; COBOL program.</p>

<ul>
<li>DMAlgol: Database Operations extensions</li>
</ul>

<p>This is the compiler for creating the Burroughs large systems database, DMSII. Incredibly useful for writing your own low level database programs, like load/dump, and to analyze the DMSII Audit Trail. I used it to extract update or delete statements. It makes extensive use of compile-time processing.</p>

<ul>
<li>BDMSAlgol: Database Access extensions</li>
</ul>

<p>This compiler allows Algol programs to open and use a DMSII database. It includes all normal database verbs. Some applications were written with this, but most used BDMSCobol.</p>

<h1 id="featuresilike">Features I like</h1>

<ul>
<li>Compile-time processing</li>
</ul>

<p>The single tick (') denoted extra processing during the compilation phase, For instance if a data structure has seven nodes you could create seven different compiled procedures, on the fly. Heavily used building the Burroughs DMSII database software yet available for any old [DC|DM|BDMS]Algol programmer.</p>

<p>Example using DMAlgol:</p>

<pre><code>'FOR EACH STR OF DBNODE WHERE STR.TYPEF = DATASET DO
  'BEGIN
...
</code></pre>

<blockquote>
<p>The compile-time facility is used to conditionally and iteratively compile ALGOL source data. This section describes the declaration and use of compile-time variables, compile-time identifiers, compile-time statements, an extension to the DEFINE declaration, and compiler control options that pertain to the compile-time facility. The compile-time facility is not allowed in the global part of a program.</p>
</blockquote>

<p>Reference: Compile-Time Facility - <a href="https://public.support.unisys.com/aseries/docs/ClearPath-MCP-21.0/86000098-519/chapter-000002156.html">https://public.support.unisys.com/aseries/docs/ClearPath-MCP-21.0/86000098-519/chapter-000002156.html</a></p>

<ul>
<li>Shared Library (with freeze-control)</li>
</ul>

<p>This is the same as every other operating system, a way to have one executable accessed by several programs.</p>

<p>Freeze-control is an option to execute some code <em>after</em> becoming available for other programs. Like running background tasks. COMS is implemented using this.</p>

<p>Example:</p>

<pre><code>BEGIN
PROCEDURE X(A,B);
  ...                     %Procedure to be exported
PROCEDURE Y(P,Q);
  ...                     %Procedure to be exported
PROCEDURE Z;
BEGIN       %Control procedure - untyped and no parameters
  ...
  WAITANDRESET (MYSELF.EXCEPTIONEVENT);
  ...
END;
EXPORT X, Y;
...
FREEZE(CONTROL,Z);
...
END.
</code></pre>

<blockquote>
<p>The program is made available as a server library, and control passes to a local procedure in the library called the control procedure, where execution continues. The control library changes into a temporary library when the control procedure is exited.</p>
</blockquote>

<p>Reference:</p>

<ol>
<li>Freezing the Library - <a href="https://public.support.unisys.com/aseries/docs/ClearPath-MCP-21.0/86000494-513/section-000080636.html">https://public.support.unisys.com/aseries/docs/ClearPath-MCP-21.0/86000494-513/section-000080636.html</a></li>
<li>Examples of FREEZE Statement - <a href="https://public.support.unisys.com/aseries/docs/ClearPath-MCP-22.0/86000098-520/86000098-520/section-000026438.html">https://public.support.unisys.com/aseries/docs/ClearPath-MCP-22.0/86000098-520/86000098-520/section-000026438.html</a></li>
</ol>

<ul>
<li>Programdump (debug)</li>
</ul>

<p>You can call programdump to get a human readable file of your code and data, suitable for debugging.</p>

<pre><code>ON ANYFAULT, PROGRAMDUMP(ARRAYS);
</code></pre>

<ul>
<li>Protection from faults</li>
</ul>

<p>If your program tries to access memory beyond it&#8217;s own, you will get a programdump to help see what went wrong, before termination.</p>

<ul>
<li>Intuitive Language Constructs</li>
</ul>

<p>Probably because of the Committee focus on Algol-58, Algol-60, and Algol-68, by the time Burroughs picked it up for the large system series mainframes it was well documented, source code examples were great, and even the Algol compiler was written in Algol. That&#8217;s why I had to compile the Algol compiler twice for a new release.</p>

<h1 id="conclusion">Conclusion</h1>

<p>As you can see, Algol means a lot more than just syntax and systems. It was a door opener for me, both financially and intellectually.</p>

<p>I&#8217;ll never forget moving into a new trailer home, 75 feet long, single-wide, with a long hallway. That hallway became my study where I poured over program listings, penciling in changes to try out once I returned to work. Perforated green-bar paper running the length of the hall, unfolded and folded; stuffed into my Gregory Algol manuals. 25 years old, with a new baby, trying to make a living.</p>

<p>Stage 4 Algol question -&gt; <a href="/linux-in-house/writing/man-or-boy.html#title">Boy or Man</a>.</p>

<h2 id="regards">Regards,</h2>

<p>&#8211; Don Cohoon</p>

<h2 id="reference">Reference</h2>

<p>Algol Reference Manual - <a href="https://public.support.unisys.com/aseries/docs/ClearPath-MCP-21.0/86000098-519/86000098-519.pdf">https://public.support.unisys.com/aseries/docs/ClearPath-MCP-21.0/86000098-519/86000098-519.pdf</a></p>

<h1 id="algolprogram">Algol Program</h1>

<p>I started writing this in 1985, before I saw Unix &#8216;top&#8217;. Turns out it&#8217;s basically the same, only in Algol, for Burroughs MCP. Wish I had a sample output&#8230;</p>

<p>File: SYMBOL/MONITOR</p>

<pre><code> $ VERSION 38.085.000
BEGIN
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       SYSTEM          - SYSTEM UTILITIES
%       SYSTEM PHASE    - Online Performance Moniter
%       PROGRAM TITLE   - (COHOON)SYMBOL/MONITOR ON USERS
%                         (COHOON)SYSTEM/MONITOR ON USERS
%       REQUEST NUMBER  - 004
%       DATE WRITTEN    - AUG, 1988
%       INSTALLED       - JANUARY 24, 1990
%       AUTHOR          - Don Cohoon
%       PURPOSE:
%               Measure system performance and spot throughput
%               problems.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
LIBRARY SITESUPPORT(LIBACCESS=BYFUNCTION);

PROCEDURE TIMESTAMP (TIMESTRING);
        EBCDIC ARRAY TIMESTRING[0];     % Cande style time
        LIBRARY SITESUPPORT;

INTEGER PROCEDURE SEARCH_MIX            % 0 = All mix entries found.
                 %----------%           % 1 = RESULTS exited call
                                        % 2 = SystemStatus error
        (SS9,
         SCR,
         RESULTS);
         ARRAY SS9[0],                % SystemStatus array
               SCR[0];                  % Scratch, passed to results
         INTEGER PROCEDURE RESULTS      % 0= Continue, 1= Exit
                 (ETITLE,               % Mix Title
                  EINFO,                % Mix Info
                  SCR);                 % Used for saving info between
                                        % calls.
                 EBCDIC ARRAY ETITLE,
                              EINFO[0];
                 ARRAY SCR[0];
                 FORMAL;
        LIBRARY SITESUPPORT;

DEFINE
        % SEARCH_MIX - Indexes into the info array. Used by any
        %              program calling this procedure.
        INFO_MIXNUMBERV    = 0#, % Active stack number
        INFO_SERIALV       = 1#, %
          STACKNOF         = [47:12]#,
          JOB_NUMBERF      = [31:16]#,
          TASK_NUMBERF     = [15:16]#,
        INFO_PRIORITYV     =2#,% Current priority
        INFO_STACKSTATEV   =3#,% Group 1 = stacks that cannot process
                               % Group 2 = stacks that have no need
                               %           the processor at the momment.
                               % Group 3 = stacks that presently have a
                               % processor or are in the READYQ.
          STACKSTATEF      = [23:4]#, % 0-5   = Group 1
                                      % 6-12  = Group 2
                                      % 13-15 = Group 3
        INFO_REPLYV        =4#,% Bit mask of allowable responses to
                               % a waiting RSVP. If the task is
                               % premature, this word contains a -1;
                               % If bit 47 is TRUE, a reply is being
                               % awaited and the following bits are
                               % valid. If 47=1 the task is also
                               % waiting on the event that is caused
                               % when the reply is entered.
          DSF              = [0:1]#,
          RMF              = [1:1]#,
          OKF              = [2:1]#,      % Remotely
          OFF              = [3:1]#,
          FRF              = [4:1]#,
          SVF              = [5:1]#,
          CLF              = [6:1]#,
          ILF              = [7:1]#,
          FMF              = [8:1]#,
          ULF              = [9:1]#,
          OUF              = [10:1]#,
          ODTOKF           = [11:1]#,     % Operator only
          AXF              = [12:1]#,
          DCKEYINF         = [13:1]#,
          QTF              = [14:1]#,
          FAF              = [15:1]#,
          NOTOKF           = [16:1]#,
          NEEDREPLYF       = [47:1]#,
        INFO_USAGEV        = 6#,
          STKISMCSF        = [47:1]#,     % Stack is a MCS
          STKMCSNRF        = [46:7]#,     % MCS number if stack is or
                                          %  ever was an MCS.
          PERMFROZLIBF     = [39:1]#,     % Permanently frozen library
          NOMEMF           = [20:1]#,     % Stack stopped, needs memory
          SORTINGF         = [18:1]#,     % Stack called SORT intrinsic
                                          %  and sorting is in progress.
        INFO_JOBINFOV      = 7#,
          WFLF             = [28:1]#, % TRUE if orig from WFL
          WFLQF            = [19:10]#,% If WFL, contains job queue
        INFO_STACKSTATUSV  = 8#,% Only valid if STACKSTATEF &gt; 5
          PRIORITYBIASF    = [47:7]#,
           IRUNNERF        = [47:1]#, % Invisible Independent Runner
           SIRUNNERF       = [46:2]#, % SWAPPER=2, AUTOBACKUP or
                                      %            DCCONTROL=3.
           MCPLOCKF        = [44:1]#, % MCP owns soft lock
           MCSF            = [43:1]#,
           DSEDF           = [42:1]#,
           CPF             = [41:1]#, % Swapped or CP or WFL
          VISABLE_PRIORITYF= [40:7]#,% Same as PRIORITY
          FINE_PRIORITYF   = [33:6]#,%
        INFO_COMPILERINFOV = 9#,
          DMSCAPABLEF      = [44:1]#,
          PRIVLEDGEDF      = [42:1]#,
          MARKLEVELF       = [23:08]#,
          CYCLENUMBERF     = [9:10]#,
        INFO_PROCESSTIMEV  =10#,   % Total processor time (2.4ms)
        INFO_READYTIMEV    =11#,   % Total ready queue time (2.4ms)
        INFO_IOTIMEV       =12#,   % Total IO time (2.4ms)
        INFO_COREINUSEV    =13#,   % Sum of all D2 memory (words)
        INFO_STACKINFOV    =14#,   % MCP info bits.
          NEEDAROWF        = [39:1]#, % Wait for new olay row
          COMPILERF        = [34:1]#, % Task is a compiler
          STACKKINDF       = [31:8]#, % MASK
            SEGDICTSTACKF  = [28:1]#, % Segment dictionary (D1) stack
          IRINDICATORF     = [25:1]#, % Independent Runner
        INFO_D1COREINUSEV  =15#,   % Sum of all D1 memory (words)
        % MISC...
        MS_TO_SECONDS(X) = ((X)*2.4@-4)#,
        PERCENT(X)       = ((X)*100 DIV ELAPSED)#,
        HLTIME           = TIME(14)*2.4@-6#,
        PRTIME           = MS_TO_SECONDS(INFO[INFO_PROCESSTIMEV])#,
        RQTIME           = MS_TO_SECONDS(INFO[INFO_READYTIMEV])#,
        IOTIME           = MS_TO_SECONDS(INFO[INFO_IOTIMEV])#,
        D1STACK          =BOOLEAN(INFO[INFO_STACKINFOV].SEGDICTSTACKF)#,
        CORE             = (INFO[INFO_COREINUSEV] +
                            INFO[INFO_D1COREINUSEV]) / 1000#, % K-Words
        PLACE(X)         = REPLACE PB:PB BY X#,
        MIXLOCKED        = BOOLEAN(INFO[INFO_STACKSTATUSV].MCPLOCKF)#,
        MIXCOMPILE       = BOOLEAN(INFO[INFO_STACKINFOV].COMPILERF)#,
        MIXSORT          = BOOLEAN(INFO[INFO_USAGEV].SORTINGF)#,
        MIXDMS           = BOOLEAN(INFO[INFO_COMPILERINFOV].DMSCAPABLEF)
                           #,
        MIXMEM           = BOOLEAN(INFO[INFO_USAGEV].NOMEMF)#,
        MIXOLAY          = BOOLEAN(INFO[INFO_STACKINFOV].NEEDAROWF)#,
        OLD_PRTIME       = T1#,
        OLD_RQTIME       = T2#,
        OLD_IOTIME       = T3#,
%        OLD_CORE         = T4#,
        BUMP(X)          = BEGIN
                           PRTHRESHOLD :=* +X;
                           RQTHRESHOLD :=* +X;
                           IOTHRESHOLD :=* +X;
                           END#,
        GRIND(X)         = BEGIN
                           PRTHRESHOLD :=* -X;
                           RQTHRESHOLD :=* -X;
                           IOTHRESHOLD :=* -X;
                           END#,
        DEFPRTHRESHOLD   = 1#,
        DEFRQTHRESHOLD   = 20#,
        DEFIOTHRESHOLD   = 50#,
        DEFPRALARM       = 30#,
        DEFRQALARM       = 70#,
        DEFIOALARM       = 70#,
        GET_OLD_TIMES    = BEGIN
                           INX := INFO[INFO_MIXNUMBERV];
                           T1  := OLD[INX*3];
                           T2  := OLD[INX*3+1];
                           T3  := OLD[INX*3+2];
                           END;#,
        SAVE_NEW_TIMES   = BEGIN
                           INX := INFO[INFO_MIXNUMBERV];
                           OLD[INX*3] := T1;
                           OLD[INX*3+1] := T2;
                           OLD[INX*3+2] := T3;
                           END;#,
      % SystemStatus 7
        SS7_NSP_INX(X)          = SS7[(SS7[1]+1)+((I*4)+X)]#,
      % SystemStatus 16
        SS16_BASE               = 5 + 4 + 1 #, % 1 For Group Size Word
        LINK_TYPE               = [47:08] #,
        HDU(X)                  = X[SS16_BASE].LINK_TYPE = 19#,
        LINK_VERSION            = [39:04] #,
        ITEM_COUNT              = [35:12] #,
        ITEM_WIDTH              = [23:08] #,
        START_INDEX             = [15:16] #,
        % Word x+0
        PHYSICAL_UNIT_NUMBER    = [47:12] #,
        FAMILY_INDEX            = [47:08] #, % HDU
        FAMILY_INDEX_NUMBER     = [35:08] #, % Non-HDU
        PACK_MODE               = [39:01] #, % HDU
        MODE                    = [27:01] #,
        % Word x+1
        UNIT_DEVICE_NUM(X)      = X[I+1]  #, % HDU
        SERIAL_NUMBER           = [47:48] #,
        % Word x+2
        PACK_SERIAL_NUMBER(X)   = X[I+2]  #, % HDU
        PACK_NAME_START(X)      = IF HDU(X) THEN
                                     POINTER(X[I+3])
                                    ELSE
                                     POINTER(X[I+2])#,
        PACK_LABEL_LENGTH       = [47:08] #,
        PACK_LABEL_FIRST_FIVE   = [39:40] #,
        % Word x+3
        PACK_LABEL_NEXT_SIX     = [47:48] #,
        % Word x+4
        PACK_LABEL_LAST_SIX     = [47:48] #,
      % SystemStatus 21
        UNITTYPE  = 1].[47:6 #,
        LABELED   = 1].[25:1 #,
        SUBTYPE   = 1].38:6 #,
        FAMILYINX = 8].[35:8 #,
        UNITNO    = 6 #,
        NAMEPOS   = 10 #,
        NAMELENGTH= 10].[47:8 #,
        PACKV     = 17 #,
        LABELEDV  = 1 #,
        IOBYTES   = 15 #,
        IOCHARGE  = 16 #,
        IOREADS   = 17].[47:24 #,
        IOWRITES  = 17].[23:24 #,
        READERRS  = 18].[47:24 #,
        WRITEERRS = 18].[23:24 #,
        DEFDISKIOTHRESHOLD = 20 #,
        DEFDISKIOALARM     = 200 #,
        OLD_IOBYTES := T1#,
        OLD_IOCHARGE:= T2#,
        OLD_IOREADS := T3.[47:24]#,
        OLD_IOWRITES:= T3.[23:24]#,
        GET_OLD_PKTIMES = BEGIN
                           T1  := SS16[PKINX*3];
                           T2  := SS16[PKINX*3+1];
                           T3  := SS16[PKINX*3+2];
                          END#,
        GET_NEW_PKTIMES = BEGIN
                           OLD_IOBYTES := SS21[IOBYTES]/1000;
                           OLD_IOCHARGE:= MS_TO_SECONDS(SS21[IOCHARGE]);
                           OLD_IOREADS := SS21[IOREADS];
                           OLD_IOWRITES:= SS21[IOWRITES];
                           SS16[PKINX*3] := T1;
                           SS16[PKINX*3+1] := T2;
                           SS16[PKINX*3+2] := T3;
                          END#,
        % SCREEN ATTRIBUTES
        ETX              = 48&quot;03&quot;#, % End of text
        HT               = 48&quot;05&quot;#, % Horizontal Tab
        FF               = 48&quot;0C&quot;#, % Form Feed
        CR               = 48&quot;0D&quot;#, % Carrage Return
        SO               = 48&quot;0E&quot;#, % Reverse Video
        ST               = 48&quot;0F&quot;#, % Underline
        FORMS            = 48&quot;12&quot;#, % &gt; &lt;
        RS               = 48&quot;1E&quot;#, % Return Seperator
        LEFT             = SUB,48&quot;1F&quot;#, % [
        RIGHT            = RS#,     % ]
        ESC              = 48&quot;27&quot;#, % Escape
        ESC_K            = ESC,&quot;K&quot;#,% Clear end of line
        DC4              = 48&quot;3C&quot;#, % Home
        SUB              = 48&quot;3F&quot;#, % Bright
        LINE24           = 48&quot;277F40F7&quot;#,
        CLS              = 48&quot;27D1&quot;#,
        % MISC
        ACT_QUITV       = 0#,
        ACT_PROCV       = 1#,
        ACT_DISKV       = 2#,
        ACT_NSPV        = 3#,
        ACT_INITV       = 99#,
        INIT_STATEV     = 0#,
        PROC_STATEV     = 1#,
        DISK_STATEV     = 2#,
        NSP_STATEV      = 3#,
        CFG_STATEV      = 4#,
        SPLIT_STATEV    = 5#;
%
FILE REM(KIND=REMOTE,MAXRECSIZE=1920,UNITS=CHARACTERS,FILEUSE=IO),
     PRT(KIND=PRINTER,UNITS=CHARACTERS,MAXRECSIZE=90),
     CFG(KIND=DISK,MAXRECSIZE=30,BLOCKSIZE=1,AREASIZE=1,AREAS=1,
         PROTECTION=SAVE);
FORMAT CFGFORMAT (2(I2),A18,2(I2),A18,2(I2),A18,I2,2(I4),2(I2));
DEFINE CFGLIST  = PRTHRESHOLD, PRALARM, SUP1,
                  RQTHRESHOLD, RQALARM, SUP2,
                  IOTHRESHOLD, IOALARM, SUP3, MXLINES,
                  DISKIOTHRESHOLD, DISKIOALARM, PKLINES,
                  CYCLE#;
TRANSLATETABLE PRINTABLES (EBCDIC TO EBCDIC,
                           48&quot;0E&quot; TO 48&quot;6E&quot;,
                           48&quot;0F&quot; TO 48&quot;40&quot;,
                           48&quot;12&quot; TO 48&quot;40&quot;,
                           48&quot;1E&quot; TO 48&quot;40&quot;,
                           48&quot;27&quot; TO 48&quot;40&quot;,
                           48&quot;3F&quot; TO 48&quot;40&quot;),
               NULLTOCR (EBCDIC TO EBCDIC,
                         48&quot;00&quot; TO 48&quot;0D&quot;,
                         48&quot;03&quot; TO 48&quot;0D&quot;);
TRUTHSET PRINTSTOP (48&quot;050D3C&quot;);
DEFINE MAXPKS = 30#;      % Resized if needed
ARRAY SCR[0:255],         % Scratch (Evaluatemix and Dckeyin)
      PKS[0:MAXPKS,0:3],  % Sorted list of pack # and names
      SS7[0:125],         % SystemStatus 7  (NSP times &amp; counts)
      SS16[0:255],        % SystemStatus 16 (Pack #'s &amp; Old Pack Times)
      SS21[0:29],         % SystemStatus 21 (Pack times &amp; counts)
      OLD[-2047:29999],   % Old Mix times and counts
      NSPA,               % Current NSP times
      OLDNSPA[0:5*4+4];   % Old NSP times (6 NSP's max)
EBCDIC ARRAY BUFFER[0:79],% Input from screen
             ESCR[0:1919],% Output to screen
             SUP[0:54];   % Prefixes to be suppressed
LONG ARRAY SS9[0:699];  % SystemStatus 9 (in SiteLibrary)
POINTER PA, PB, PX;
INTEGER RSLT,
        PKINX,
        PKLINES,
        PKSELECTED,
        MXLINES,
        MXSELECTED,
        INX,
        CURRENT_STATE,
        PRTHRESHOLD,
        RQTHRESHOLD,
        IOTHRESHOLD,
        PRALARM,
        RQALARM,
        IOALARM,
        DISKIOTHRESHOLD,
        DISKIOALARM,
        SUP1_LEN,
        SUP2_LEN,
        SUP3_LEN;
REAL
        T1,
        T2,
        T3,
        T4,
        TEMP_IOBYTES,
        TOTL_IOBYTES,
        TEMP_IOCHARGE,
        TOTL_IOCHARGE,
        TEMP_IOREADS,
        TOTL_IOREADS,
        TEMP_IOWRITES,
        TOTL_IOWRITES,
        TOTL_NSP_CHAR_SENT,
        TOTL_NSP_COUNT_SENT,
        TOTL_NSP_CHAR_READ,
        TOTL_NSP_COUNT_READ,
        PRTOTAL,
        RQTOTAL,
        IOTOTAL,
        CUTOTAL,
 $
        MXTOTAL,
        ELAPSED,
        DELAY,
        CYCLE,
        CLOCK,
        NEWCLOCK,
        SUPPRESS,
        ACTION,
 $
        MAX_PACK_NUMBER;
BOOLEAN
        HARD_COPY,
        EXIT,
        SPLITSCREEN,
        S,
        INITIALIZED;
ARRAY
        TYMES[0:2];
DEFINE
        P      = POINTER#,
        PRTEMP = TYMES[0]#,
        RQTEMP = TYMES[1]#,
        IOTEMP = TYMES[2]#;
DEFINE
       SUP_SIZ  = 18#,
       SUP1     = SUP[0]#,
       SUP2     = SUP[18]#,
       SUP3     = SUP[36]#,
       STKF     = [47:01]#,
       SET_SUPPRESSED =
                  IF SUP1_LEN &gt; 0 THEN
                   IF NOT S:=ETITLE = SUP1 FOR SUP1_LEN THEN
                    IF SUP2_LEN &gt; 0 THEN
                     IF NOT S:=ETITLE = SUP2 FOR SUP2_LEN THEN
                      IF SUP3_LEN &gt; 0 THEN
                       S:=ETITLE = SUP3 FOR SUP3_LEN;
                  IF S THEN SUPPRESS.STKF := 1#,
       RESET_SUPPRESSED = SUPPRESS.STKF := 0#,
   STACK_IS_IR  = INFO[INFO_STACKINFOV].IRINDICATORF = 1#,
   SUPPRESS_IRS = SUPPRESS.IRINDICATORF = 0#,
   SUPPRESS_STK = SUPPRESS.STKF = 1#,
   DIGITSOF (X) =
    ((FIRSTONE(SCALERIGHTF((X),12))-1).[5:4]+1)#,
   ERR(X)       =
    BEGIN
     REPLACE PB:ESCR BY LINE24, SUB, SO, X, DC4;
     WRITE(REM,OFFSET(PB),ESCR);
     CURRENT_STATE := INIT_STATEV;
     WHEN(2);
    END#,
   TIMER         = DELAY := CYCLE;
                   ELAPSED := (NEWCLOCK:=HLTIME) - CLOCK;
                   CLOCK := NEWCLOCK;
                   #,
 $
   WAITER        = RSLT:=WAIT((CYCLE),REM.INPUTEVENT)
                   #,
   CONFIG_SCREEN =
    REPLACE PB:ESCR BY FF, HT FOR 2, &quot;Configuration Menu&quot;, CR, ST,
                       CR FOR 2, SUB, &quot;Processor Options&quot;, CR,
                        HT FOR 2, &quot;Threshold Alarm&quot;,
                        HT FOR 2, &quot;Suppress&quot;, CR,
                       &quot; Processor.......&quot;,
                        LEFT, PRTHRESHOLD FOR 2 DIGITS, RIGHT,
                       &quot; &quot; FOR 3,
                        LEFT, PRALARM FOR 2 DIGITS, RIGHT,
                        HT, LEFT, SUP1 FOR SUP_SIZ, RIGHT, CR,
                       &quot; Ready Queue.....&quot;,
                        LEFT, RQTHRESHOLD FOR 2 DIGITS, RIGHT,
                       &quot; &quot; FOR 3,
                        LEFT, RQALARM FOR 2 DIGITS, RIGHT,
                        HT, LEFT, SUP2 FOR SUP_SIZ, RIGHT, CR,
                       &quot; IO Time.........&quot;,
                        LEFT, IOTHRESHOLD FOR 2 DIGITS, RIGHT,
                       &quot; &quot; FOR 3,
                        LEFT, IOALARM FOR 2 DIGITS, RIGHT,
                        HT, LEFT, SUP3 FOR SUP_SIZ, RIGHT, CR,
                       &quot; Display Lines...&quot;,
                        LEFT, MXLINES FOR 2 DIGITS, RIGHT,
                        CR FOR 2,
                        ST, CR FOR 2,
                        SUB, &quot;Disk Options&quot;, CR,
                        HT FOR 2, &quot;Threshold Alarm&quot;, CR,
                       &quot; IO Time.........&quot;,
                        LEFT, DISKIOTHRESHOLD FOR 4 DIGITS, RIGHT,
                       &quot; &quot;,
                        LEFT, DISKIOALARM FOR 4 DIGITS, RIGHT, CR,
                       &quot; Display Lines...&quot;,
                        LEFT, PKLINES FOR 2 DIGITS, RIGHT,
                        CR FOR 2, ST, CR FOR 2,
                       &quot; Cycle delay.....&quot;,
                        LEFT, CYCLE FOR 2 DIGITS, RIGHT,
                        FORMS#,
   SPLIT_HEADING=
    REPLACE PB:ESCR BY DC4, HT FOR 2, CLS, &quot;Multiple Monitor&quot;, HT FOR 2,
                       BUFFER FOR 32, ST,
                       &quot;MCP+/- Processor Disk Nsp Configuration Quit&quot;,
                       CR#,
   PROC_HEADING =
    REPLACE PB:ESCR BY DC4, HT FOR 2, CLS,&quot;Processor Monitor&quot;, HT FOR 2,
                       BUFFER FOR 32, ST,
                       &quot;MCP+/- Disk Nsp Split Configuration Quit&quot;, CR#,
   PROC_TITLES =
    REPLACE PB:PB BY   SUB,&quot;Mix Priority Flags Task name&quot;,
                       &quot; &quot; FOR 18,
                       &quot;%PR      RQ       IO      CU(k)  &quot;#,
   PACK_HEADING   =
    REPLACE PB:ESCR BY DC4, HT FOR 2, CLS, &quot;Disk Monitor&quot;, HT FOR 2,
                       BUFFER FOR 32, CR, ST,
                       &quot;Proc Nsp Configuration Quit&quot;, CR#,
   PACK_TITLES =
    REPLACE PB:PB BY   SUB, &quot;Unit Name             Inx    K-Bytes &quot;,
                       &quot;Io Time   Reads  Writes     IO's&quot;, CR#,
   NSP_HEADING =
    REPLACE PB:ESCR BY DC4, HT FOR 2, CLS, &quot;NSP Monitor&quot;, HT FOR 2,
                       BUFFER FOR 32, CR, ST,
                       &quot;Proc Disk Configuration Quit&quot;, CR#,
   NSP_TITLES =
    REPLACE PB:PB BY SUB,
              &quot;NSP       Chars       Count       Chars       Count    &quot;,
              &quot;  Total       Total&quot;,CR, SUB,
              &quot;          Sent        Sent        Read        Read     &quot;,
              &quot;  Chars       IO's&quot;,CR#;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       INITIALIZE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
PROCEDURE INITIALIZE;
BEGIN
  IF NOT INITIALIZED THEN
     BEGIN
     INTEGER I,J;
     BOOLEAN B;
     INITIALIZED := TRUE;
     REPLACE BUFFER BY MYSELF.STACKNO FOR * DIGITS, &quot;SUPPRESS&quot;, 48&quot;00&quot;;
     DCKEYIN(BUFFER,SCR);
     REPLACE BUFFER BY MYSELF.STACKNO FOR * DIGITS, &quot;PR99&quot;, 48&quot;00&quot;;
     DCKEYIN(BUFFER,SCR);
     DO BEGIN % Obtain a list of all pack unit numbers
        SYSTEMSTATUS(SS16,16,0 &amp; 1 [4:1]);
        IF (I := SS16[SS16_BASE].START_INDEX) = 0 THEN
           RESIZE(SS16,SIZE(SS16)+5);
        END
     UNTIL I NEQ 0;
 $ SET OMIT
     MIN_PACK_NUMBER:=MAX_PACK_NUMBER:=
      IF HDU(SS16) THEN UNIT_DEVICE_NUM(SS16)
        ELSE
         SS16[I].PHYSICAL_UNIT_NUMBER;
 $ POP OMIT
     J := 0;
     DO BEGIN
        PKS[J,0] := IF HDU(SS16) THEN UNIT_DEVICE_NUM(SS16)
                     ELSE SS16[I].PHYSICAL_UNIT_NUMBER;
        REPLACE POINTER(PKS[J,1]) BY PACK_NAME_START(SS16)
                                     FOR 18;
        IF (J:=* +1) &gt;= SIZE(PKS[*,*]) THEN
           RESIZE(PKS[*,*],J+10,RETAIN);
 $ SET OMIT
        MIN_PACK_NUMBER :=
           MIN(IF HDU(SS16) THEN UNIT_DEVICE_NUM(SS16)
                ELSE SS16[I].PHYSICAL_UNIT_NUMBER,MIN_PACK_NUMBER);
        MAX_PACK_NUMBER :=
           MAX(IF HDU(SS16) THEN UNIT_DEVICE_NUM(SS16)
                ELSE SS16[I].PHYSICAL_UNIT_NUMBER,MAX_PACK_NUMBER);
 $ POP OMIT
        I :=* + SS16[SS16_BASE].ITEM_WIDTH;
        END UNTIL I = SS16[0]; % Group Size Word
     MAX_PACK_NUMBER := SIZE(PKS[*,*]);
     RESIZE(SS16,MAX_PACK_NUMBER*3+3); % Make room for Times and Counts
     DO BEGIN
        B:=TRUE;
        FOR I := 0 STEP 1 UNTIL J-1 DO
        IF POINTER(PKS[I,1])+1 &gt; POINTER(PKS[I+1,1])+1 FOR 17 THEN
           BEGIN
           B:=FALSE;
           PKS[I,0] := READLOCK(PKS[I,0],PKS[I+1,0]);
           PKS[I,1] := READLOCK(PKS[I,1],PKS[I+1,1]);
           PKS[I,2] := READLOCK(PKS[I,2],PKS[I+1,2]);
           PKS[I,3] := READLOCK(PKS[I,3],PKS[I+1,3]);
           END;
        END UNTIL B;
     IF CFG.AVAILABLE = 1 THEN
        BEGIN
        READ(CFG,CFGFORMAT,CFGLIST);
        CLOSE(CFG,CRUNCH);
        SCAN SUP1 FOR SUP1_LEN:SUP_SIZ UNTIL = &quot; &quot;;
        SUP1_LEN := SUP_SIZ-SUP1_LEN;
        SCAN SUP2 FOR SUP2_LEN:SUP_SIZ UNTIL = &quot; &quot;;
        SUP2_LEN := SUP_SIZ-SUP2_LEN;
        SCAN SUP3 FOR SUP3_LEN:SUP_SIZ UNTIL = &quot; &quot;;
        SUP3_LEN := SUP_SIZ-SUP3_LEN;
 $
        IF MXLINES &lt; 19 THEN SPLITSCREEN := TRUE;
        END
       ELSE
        BEGIN
        PKLINES := MXLINES := 19;
        REPLACE SUP BY &quot; &quot; FOR SIZE(SUP);
        PRTHRESHOLD := DEFPRTHRESHOLD;
        RQTHRESHOLD := DEFRQTHRESHOLD;
        IOTHRESHOLD := DEFIOTHRESHOLD;
        PRALARM := DEFPRALARM;
        RQALARM := DEFRQALARM;
        IOALARM := DEFIOALARM;
        DISKIOTHRESHOLD := DEFDISKIOTHRESHOLD;
        DISKIOALARM := DEFDISKIOALARM;
        END; % NO CFG FILE
     END;
  DELAY := ELAPSED := NEWCLOCK := CLOCK := 0;
  CYCLE := 20;
END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       SEND PAGE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
BOOLEAN PROCEDURE SEND_PAGE;
BEGIN
LABEL BACK;
  REPLACE PB:PB BY DC4;
  IF NOT HARD_COPY THEN
     SEND_PAGE := WRITE(REM,OFFSET(PB),ESCR)
  ELSE
     BEGIN
     REPLACE ESCR BY ESCR FOR OFFSET(PB) WITH PRINTABLES;
     PX := ESCR;
     DO
       BEGIN
         REPLACE PA := BUFFER BY &quot; &quot; FOR 80;
     BACK:
         REPLACE PA:PA BY PX:PX
          FOR REMAININGCHARS(PA) UNTIL IN PRINTSTOP;
         IF PX = HT THEN
            BEGIN
            REPLACE PA:PA BY &quot; &quot; FOR
             ( ((INTEGERT(OFFSET(PA)/8)*8)+8) - OFFSET(PA) );
            PX :=* +1;
            GO BACK;
            END;
         SEND_PAGE := WRITE(PRT,OFFSET(PA),BUFFER);
         IF PX &lt; &quot; &quot; THEN PX :=* +1;
       END UNTIL OFFSET(PX) GEQ OFFSET(PB);
     REPLACE BUFFER BY &quot;=&quot; FOR 80;
     WRITE(PRT,80,BUFFER);
     END;
  TIMESTAMP(BUFFER);
  CASE CURRENT_STATE OF
       BEGIN
       (PROC_STATEV):
        PROC_HEADING;
       (DISK_STATEV):
        PACK_HEADING;
       (NSP_STATEV):
        NSP_HEADING;
       (SPLIT_STATEV):
        SPLIT_HEADING;
       END;
END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       CONFIGURATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
PROCEDURE CONFIGURATION;
BEGIN
LABEL BOOBOO;
  CONFIG_SCREEN;
BOOBOO:
  WRITE(REM,OFFSET(PB),ESCR);
  IF NOT READ(REM[TIMELIMIT 0],CFGFORMAT,CFGLIST) THEN
   IF (IF (MXLINES NEQ 19) THEN (MXLINES+PKLINES &lt; 17) ELSE TRUE) THEN
     BEGIN
     SCAN SUP1 FOR SUP1_LEN:SUP_SIZ UNTIL = &quot; &quot;;
     SUP1_LEN := SUP_SIZ-SUP1_LEN;
     SCAN SUP2 FOR SUP2_LEN:SUP_SIZ UNTIL = &quot; &quot;;
     SUP2_LEN := SUP_SIZ-SUP2_LEN;
     SCAN SUP3 FOR SUP3_LEN:SUP_SIZ UNTIL = &quot; &quot;;
     SUP3_LEN := SUP_SIZ-SUP3_LEN;
     WRITE(CFG,CFGFORMAT,CFGLIST);
     CLOSE(CFG,CRUNCH);
     END
   ELSE
     BEGIN
     REPLACE PB:PB-1 BY CR, SUB, &quot;Processor + Disk display lines&quot;,
                        &quot; must be less than 17, or both = 19, &quot;,
                        &quot;Try agin.&quot;, FORMS;
     GO BOOBOO;
     END;
END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       ODT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
PROCEDURE ODT;
BEGIN
  REPLACE POINTER(SCR) BY 48&quot;00&quot; FOR SIZE(SCR) WORDS;
  DCKEYIN(BUFFER[1],SCR);
  SCAN POINTER(SCR) FOR INX:1536 UNTIL = ETX;
  REPLACE PB:ESCR BY FF, CR,
                     POINTER(SCR[0]) FOR 1536-INX WITH NULLTOCR,
                     DC4,ESC_K, &quot;Return&quot;;
  WRITE(REM,OFFSET(PB),ESCR);
  IF READ(REM[TIMELIMIT CYCLE]) THEN;
END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       HANDLE INPUT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
BOOLEAN PROCEDURE HANDLE_INPUT(STATE);
INTEGER STATE;
BEGIN
    CASE STATE OF
         BEGIN
    (INIT_STATEV):
         INITIALIZE;
         ACTION := ACT_INITV;
         TIMESTAMP(BUFFER);
         REPLACE PB:ESCR BY FF, HT FOR 2, &quot;Resource Monitor&quot;, HT FOR 2,
                            BUFFER FOR 32,
                            ST, &quot;Processor Disk Nsp Configuration Quit&quot;,
                            DC4;

         WRITE(REM,OFFSET(PB),ESCR);
         READ(REM[TIMELIMIT 0],35,BUFFER);
         CASE REAL(BUFFER[0],1) OF
              BEGIN
                (&quot;Q&quot;): ACTION := ACT_QUITV;
                (&quot;P&quot;): ACTION := ACT_PROCV;
                (&quot;D&quot;): ACTION := ACT_DISKV;
                (&quot;N&quot;): ACTION := ACT_NSPV;
                (&quot;O&quot;): ODT;
                (&quot;C&quot;): CONFIGURATION;
                ELSE:
                       HANDLE_INPUT := TRUE;
              END;
    (PROC_STATEV):
    (SPLIT_STATEV):
         CASE REAL(BUFFER[0],1) OF
          BEGIN % PROCESSOR
          (&quot;H&quot;): HARD_COPY := TRUE;
          (&quot;P&quot;): SPLITSCREEN := FALSE;
                 MXLINES:=PKLINES:=19;
                 ACTION := ACT_PROCV;
          (&quot;M&quot;): IF BUFFER[3] = &quot;+&quot; THEN SUPPRESS.IRINDICATORF := 1
                   ELSE SUPPRESS.IRINDICATORF := 0;
                 ACTION := ACT_PROCV;
          (&quot;D&quot;): ACTION := ACT_DISKV;
                 SPLITSCREEN := FALSE;
                 MXLINES:=PKLINES:=19;
                 INITIALIZE;
          (&quot;N&quot;): ACTION := ACT_NSPV;
                 SPLITSCREEN := FALSE;
                 MXLINES:=PKLINES:=19;
                 INITIALIZE;
          (&quot;O&quot;): ODT;
          (&quot;C&quot;): CONFIGURATION;
          (&quot;S&quot;): SPLITSCREEN := TRUE;
                 IF MXLINES+PKLINES &gt; 16 THEN
                    MXLINES:=PKLINES:=8;
          (&quot;Q&quot;): ACTION := ACT_QUITV;
          ELSE :
                 HANDLE_INPUT := TRUE;
          END;
     (DISK_STATEV):
         CASE REAL(BUFFER[0],1) OF
           BEGIN % DISK
          (&quot;P&quot;):
                 INITIALIZE;
                 ACTION := ACT_PROCV;
          (&quot;N&quot;): ACTION := ACT_NSPV;
                 INITIALIZE;
          (&quot;O&quot;): ODT;
          (&quot;C&quot;): CONFIGURATION;
          (&quot;Q&quot;): ACTION := ACT_QUITV;
          ELSE:
                HANDLE_INPUT := TRUE;
          END;
     (NSP_STATEV):
         CASE REAL(BUFFER[0],1) OF
          BEGIN
          (&quot;P&quot;):
                 INITIALIZE;
                 ACTION := ACT_PROCV;
          (&quot;D&quot;): INITIALIZE;
                 ACTION := ACT_DISKV;
          (&quot;O&quot;): ODT;
          (&quot;C&quot;): CONFIGURATION;
          (&quot;Q&quot;): ACTION := ACT_QUITV;
          ELSE:
                 HANDLE_INPUT := TRUE;
          END;
         END OF CASE STATE;
END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       NSP Display
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
BOOLEAN PROCEDURE NSP_DISPLAY;
BEGIN
    REPLACE PB:PB BY
                SUB, &quot;Totals&quot;,
                &quot; &quot; FOR 8-DIGITSOF(TOTL_NSP_CHAR_SENT),
                TOTL_NSP_CHAR_SENT FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(TOTL_NSP_COUNT_SENT),
                TOTL_NSP_COUNT_SENT FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(TOTL_NSP_CHAR_READ),
                TOTL_NSP_CHAR_READ FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(TOTL_NSP_COUNT_READ),
                TOTL_NSP_COUNT_READ FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(TOTL_NSP_CHAR_SENT+
                                    TOTL_NSP_CHAR_READ),
                TOTL_NSP_CHAR_SENT +TOTL_NSP_CHAR_READ FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(TOTL_NSP_COUNT_SENT+
                                    TOTL_NSP_COUNT_READ),
                TOTL_NSP_COUNT_SENT+TOTL_NSP_COUNT_READ FOR * DIGITS,
                DC4;
    NSP_DISPLAY := WRITE(REM,OFFSET(PB),ESCR);
    TIMESTAMP(BUFFER);
    NSP_HEADING;
END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       NSP Info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
PROCEDURE NSPINFO;
BEGIN
INTEGER I;
SYSTEMSTATUS(SS7,7,0);
FOR I := ((SS7[SS7[1]+1]-1)/4)-1 STEP-1 UNTIL 0 DO %Calcule NSP Number
    BEGIN
    T1 := (NSPA[I*4]   := SS7_NSP_INX(1))-OLDNSPA[I*4];
    TOTL_NSP_CHAR_SENT :=* + T1;
    T2 := (NSPA[I*4+1] := SS7_NSP_INX(2))-OLDNSPA[I*4+1];
    TOTL_NSP_COUNT_SENT:=* + T2;
    T3 := (NSPA[I*4+2] := SS7_NSP_INX(3))-OLDNSPA[I*4+2];
    TOTL_NSP_CHAR_READ :=* + T3;
    T4 := (NSPA[I*4+3] := SS7_NSP_INX(4))-OLDNSPA[I*4+3];
    TOTL_NSP_COUNT_READ:=* + T4;
    REPLACE PB:PB BY &quot; &quot;, I FOR 2 DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(T1), T1 FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(T2), T2 FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(T3), T3 FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(T4), T4 FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(T1+T3), T1+T3 FOR * DIGITS,
                &quot; &quot; FOR 12-DIGITSOF(T2+T4), T2+T4 FOR * DIGITS,
                48&quot;0D&quot;;
    END;
REPLACE POINTER(OLDNSPA) BY POINTER(NSPA) FOR SIZE(NSPA) WORDS;
END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       Pack Totals
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
PROCEDURE PACK_TOTALS;
BEGIN
    REPLACE PB:PB BY
               SUB, &quot;Totals =================&gt;   &quot;,
               &quot; &quot; FOR 8-DIGITSOF(TOTL_IOBYTES),
               TOTL_IOBYTES FOR * DIGITS,
               &quot; &quot; FOR 8-DIGITSOF(TOTL_IOCHARGE),
               TOTL_IOCHARGE  FOR * DIGITS,
               &quot; &quot; FOR 8-DIGITSOF(TOTL_IOREADS),
               TOTL_IOREADS FOR * DIGITS,
               &quot; &quot; FOR 8-DIGITSOF(TOTL_IOWRITES),
               TOTL_IOWRITES FOR * DIGITS,
               &quot; &quot; FOR 8-DIGITSOF(TOTL_IOREADS+TOTL_IOWRITES),
               TOTL_IOREADS+TOTL_IOWRITES FOR * DIGITS;
 $ SET VOIDT
 $ POP VOIDT
END;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       Pack Info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
PROCEDURE PACKINFO;
         %--------%
 $
 $
BEGIN
%
%
%
 $
DO
  BEGIN
    IF NOT SYSTEMSTATUS(SS21,21,PKS[PKINX,0]) THEN
            IF (SS21[UNITTYPE] = PACKV) AND
               (SS21[LABELED]  = LABELEDV) THEN
                BEGIN
                GET_OLD_PKTIMES;
                TOTL_IOBYTES :=* +
                (TEMP_IOBYTES := (SS21[IOBYTES]/1000)-OLD_IOBYTES);
                TOTL_IOCHARGE :=* + (TEMP_IOCHARGE
                  :=(MS_TO_SECONDS(SS21[IOCHARGE]))-OLD_IOCHARGE);
                TOTL_IOREADS :=* +
                (TEMP_IOREADS := SS21[IOREADS]-OLD_IOREADS);
                TOTL_IOWRITES :=* +
                (TEMP_IOWRITES:= SS21[IOWRITES]-OLD_IOWRITES);
                IF TEMP_IOCHARGE &gt; DISKIOTHRESHOLD THEN
                   BEGIN
                   PKSELECTED :=* +1;
                   REPLACE PB:PB BY &quot; &quot; FOR 4-DIGITSOF(SS21[UNITNO]),
                   SS21[UNITNO] FOR * DIGITS,
                   &quot; &quot;, POINTER(SS21[NAMEPOS]) + 1 FOR
                   SS21[NAMELENGTH], &quot; &quot; FOR 18-SS21[NAMELENGTH],
                   &quot;#&quot;,
                   SS21[FAMILYINX] FOR 2 DIGITS;
                   IF TEMP_IOCHARGE &gt; DISKIOALARM THEN
                      REPLACE PB:PB BY SUB, &quot;  &quot;
                     ELSE
                      REPLACE PB:PB BY &quot;   &quot;;
                   REPLACE PB:PB BY
                   &quot; &quot; FOR 8-DIGITSOF(TEMP_IOBYTES),
                   TEMP_IOBYTES FOR * DIGITS,
                   &quot; &quot; FOR 8-DIGITSOF(TEMP_IOCHARGE),
                   TEMP_IOCHARGE FOR * DIGITS,
                   &quot; &quot; FOR 8-DIGITSOF(TEMP_IOREADS),
                   TEMP_IOREADS FOR * DIGITS,
                   &quot; &quot; FOR 8-DIGITSOF(TEMP_IOWRITES),
                   TEMP_IOWRITES FOR * DIGITS,
                   &quot; &quot; FOR 8-DIGITSOF(TEMP_IOREADS+TEMP_IOWRITES),
                   TEMP_IOREADS+TEMP_IOWRITES FOR * DIGITS, CR;
    %              SS21[READERRS] FOR * DIGITS, &quot; R-Errs,&quot;,
    %              SS21[WRITEERRS] FOR * DIGITS, &quot; W-Errs;&quot;;
                   IF PKSELECTED &gt; PKLINES THEN
                      BEGIN
                      EXIT := TRUE;
 $ SET VOIDT
                      DISKIOTHRESHOLD :=* + 25;
                      IF NOT SPLITSCREEN THEN
                         BEGIN
                         PACK_TOTALS;
                         IF SEND_PAGE THEN ACTION := ACT_QUITV;
                         WAITER;
                         CLOCK := HLTIME;
                         END;
                      PKSELECTED := 0;
                      END
                    ELSE
                      IF PKSELECTED &lt; PKLINES-3 THEN
                       IF DISKIOTHRESHOLD &gt; 3 THEN
                         DISKIOTHRESHOLD :=* -3;
 $ POP VOIDT
                   END; % Of selected packs
                GET_NEW_PKTIMES;
                END;
    PKINX:= * + 1;
    IF PKINX = MAX_PACK_NUMBER THEN EXIT := TRUE;
  END UNTIL EXIT;
END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       PROC TOTALS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
PROCEDURE PROC_TOTALS;
BEGIN
 $
  REPLACE PB:PB BY ST, SUB &quot;Totals for system; &quot;,
                       MXSELECTED FOR * DIGITS, &quot; of &quot;,
                       MXTOTAL FOR * DIGITS,
                       &quot; Tasks selected;&quot;,   HT,
                       PRTOTAL FOR * DIGITS, HT,
                       RQTOTAL FOR * DIGITS, HT,
                       IOTOTAL FOR * DIGITS, HT,
                       CUTOTAL FOR * DIGITS;
 $ SET VOIDT
 $ POP VOIDT
END;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       EVALUATE MIX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
INTEGER PROCEDURE EVALUATEMIX (ETITLE, EINFO, SCR);
        EBCDIC ARRAY ETITLE,
                     EINFO[0];
        ARRAY SCR[0];
BEGIN
        ARRAY INFO[0] = EINFO[*];
        GET_OLD_TIMES;
        MXTOTAL :=* +1;
        CUTOTAL :=* + INFO[INFO_COREINUSEV]/1000; % D2 Only
        PRTOTAL :=* + PRTEMP:=(PRTIME-OLD_PRTIME)/ELAPSED;
        RQTOTAL :=* + RQTEMP:=(RQTIME-OLD_RQTIME)/ELAPSED;
        IOTOTAL :=* + IOTEMP:=(IOTIME-OLD_IOTIME)/ELAPSED;
        SET_SUPPRESSED;
        IF (PRTEMP &gt; PRTHRESHOLD OR
            RQTEMP &gt; RQTHRESHOLD OR
            IOTEMP &gt; IOTHRESHOLD) THEN
        IF (STACK_IS_IR AND SUPPRESS_IRS OR
            SUPPRESS_STK) THEN
           BEGIN
            RESET_SUPPRESSED;
           END
          ELSE
           BEGIN
           MXSELECTED :=* +1;
           REPLACE PB:PB BY
                   &quot; &quot; FOR 4-DIGITSOF(INFO[INFO_MIXNUMBERV]),
                   INFO[INFO_MIXNUMBERV] FOR * DIGITS ,
                   &quot; &quot;,
                   &quot; &quot; FOR 3-DIGITSOF(INFO[INFO_PRIORITYV]),
                   INFO[INFO_PRIORITYV]  FOR * DIGITS,
                   &quot;.&quot;,
                   INFO[INFO_STACKSTATUSV].FINE_PRIORITYF
                    FOR 2 DIGITS, &quot;  &quot;;
                   IF MIXLOCKED THEN PLACE(&quot;L&quot;) ELSE PLACE(&quot; &quot;);
                   IF MIXCOMPILE THEN PLACE(&quot;C&quot;) ELSE PLACE(&quot; &quot;);
                   IF MIXSORT THEN PLACE(&quot;S&quot;) ELSE PLACE(&quot; &quot;);
                   IF MIXDMS THEN PLACE(&quot;D&quot;) ELSE PLACE(&quot; &quot;);
                   IF MIXMEM THEN PLACE(&quot;M&quot;) ELSE PLACE(&quot; &quot;);
                   IF MIXOLAY THEN PLACE(&quot;O&quot;) ELSE PLACE(&quot; &quot;);
                   REPLACE PB:PB BY &quot; &quot;,
                     ETITLE FOR 26;
                   IF PRTEMP &lt;= PRALARM THEN
                      REPLACE PB:PB BY &quot; &quot;,
                                       &quot; &quot; FOR 3-DIGITSOF(PRTEMP),
                                       PRTEMP FOR * DIGITS, &quot;    &quot;
                     ELSE
                      REPLACE PB:PB BY SO,
                                       &quot; &quot; FOR 3-DIGITSOF(PRTEMP),
                                       PRTEMP FOR * DIGITS, RS, &quot;   &quot;;
                   IF RQTEMP &lt;= RQALARM THEN
                      REPLACE PB:PB BY &quot; &quot;,
                                       &quot; &quot; FOR 3-DIGITSOF(RQTEMP),
                                       RQTEMP FOR * DIGITS, &quot;     &quot;
                     ELSE
                      REPLACE PB:PB BY SO,
                                       &quot; &quot; FOR 3-DIGITSOF(RQTEMP),
                                       RQTEMP FOR * DIGITS, RS, &quot;    &quot;;
                   IF IOTEMP &lt;= IOALARM THEN
                      REPLACE PB:PB BY &quot; &quot;,
                                       &quot; &quot; FOR 3-DIGITSOF(IOTEMP),
                                       IOTEMP FOR * DIGITS, &quot;     &quot;
                     ELSE
                      REPLACE PB:PB BY SO,
                                       &quot; &quot; FOR 3-DIGITSOF(IOTEMP),
                                       IOTEMP  FOR * DIGITS, RS, &quot;    &quot;;
                   REPLACE PB:PB BY &quot; &quot; FOR 3-DIGITSOF(CORE),
                                    CORE FOR * DIGITS, CR;
               IF MXSELECTED &gt; MXLINES THEN
                 BEGIN
                 BUMP(3);
                 IF NOT SPLITSCREEN THEN
                  BEGIN
                  PROC_TOTALS;
                  IF SEND_PAGE THEN EVALUATEMIX := 1
                     ELSE
                     BEGIN
                     IF WAITER = 2 THEN EVALUATEMIX :=1;
                     CLOCK := HLTIME;
                     END;
                  MXSELECTED := 0;
                  END
                 ELSE
                  BEGIN
                  EXIT := FALSE;
                  IF PKINX=MAX_PACK_NUMBER THEN
                     BEGIN
                     TOTL_IOBYTES := TOTL_IOCHARGE :=
                     TOTL_IOREADS := TOTL_IOWRITES :=
                     PKINX :=0;
                     END;
                  PKSELECTED :=0;
                  PROC_TOTALS;
                  MXSELECTED :=0;
                  REPLACE PB:PB BY CR;
                  PACK_TITLES;
                  PACKINFO;
                  PACK_TOTALS;
                  IF SEND_PAGE THEN EVALUATEMIX := 1
                     ELSE
                     BEGIN
                     IF WAITER = 2 THEN EVALUATEMIX :=1;
                     CLOCK := HLTIME;
                     END;
                  END;
                 END
               ELSE
                 IF MXSELECTED &lt; MXLINES-2 THEN
                  IF PRTHRESHOLD &gt; 2 THEN GRIND(2);
              END; % Of Selected Tasks
        OLD_PRTIME := PRTIME;
        OLD_RQTIME := RQTIME;
        OLD_IOTIME := IOTIME;
        SAVE_NEW_TIMES;
END;
%=======================================================================
%       p r o c e s s o r                                              %
%=======================================================================
PROCEDURE PROCESSOR;
BEGIN
 TIMESTAMP(BUFFER);
 IF NOT SPLITSCREEN THEN
    BEGIN
    CURRENT_STATE := PROC_STATEV;
    PROC_HEADING;
    END
  ELSE
    BEGIN
    CURRENT_STATE := SPLIT_STATEV;
    SPLIT_HEADING;
    END;
 WHILE READ(REM[TIMELIMIT (DELAY-(HLTIME-CLOCK))],35,BUFFER) DO
  BEGIN
  TIMER;
 $ SET VOIDT
 $ POP VOIDT
  PRTOTAL:=RQTOTAL:=IOTOTAL:=CUTOTAL:=MXTOTAL:=MXSELECTED:=0;
  PROC_TITLES;
  IF RSLT := SEARCH_MIX (SS9,SCR,EVALUATEMIX) &gt; 0 THEN
   CASE RSLT OF
        BEGIN
            1:  DISPLAY(&quot;EOF on write to remote terminal&quot;);
            2:  DISPLAY(&quot;SystemStatus error&quot;);
        END
   ELSE
   BEGIN
   PROC_TOTALS;
   IF SPLITSCREEN THEN
      BEGIN
      REPLACE PB:PB BY CR;
      PACK_TITLES;
      EXIT:=FALSE;
      PKSELECTED := 0;
      IF PKINX = MAX_PACK_NUMBER THEN
         BEGIN
         TOTL_IOBYTES := TOTL_IOCHARGE :=
         TOTL_IOREADS := TOTL_IOWRITES :=
         PKINX := 0;
         END;
      PACKINFO;
 $
      PACK_TOTALS;
      END;
   IF SEND_PAGE THEN ACTION := ACT_QUITV;
   END;
  END;
 $
END OF PROCEDURE PROCESSOR;
%=======================================================================
%       Input Output                                                   %
%=======================================================================
 PROCEDURE DISK;
BEGIN
  CURRENT_STATE := DISK_STATEV;
 $ SET VOIDT
 $ POP VOIDT
  TIMESTAMP(BUFFER);
  PACK_HEADING;
  WHILE READ(REM[TIMELIMIT (DELAY-(HLTIME-CLOCK))],35,BUFFER) DO
   BEGIN
    TIMER;
    EXIT := FALSE;
    IF PKINX = MAX_PACK_NUMBER THEN PKINX :=0;
    PKSELECTED := TOTL_IOBYTES := TOTL_IOCHARGE :=
                  TOTL_IOREADS := TOTL_IOWRITES :=0;
    PACK_TITLES;
    PACKINFO;
    PACK_TOTALS;
    IF SEND_PAGE THEN ACTION := ACT_QUITV;
   END;
 $
 $
END OF PROCEDURE DISK;
%=======================================================================
%       NSP
%=======================================================================
PROCEDURE NSP;
BEGIN
  CURRENT_STATE := NSP_STATEV;
  TIMESTAMP(BUFFER);
  NSP_HEADING;
  WHILE READ(REM[TIMELIMIT (DELAY-(HLTIME-CLOCK))],35,BUFFER) DO
   BEGIN
    DELAY := CYCLE;
    ELAPSED := (NEWCLOCK:=HLTIME) - CLOCK;
    CLOCK := NEWCLOCK;
    TOTL_NSP_CHAR_SENT:=TOTL_NSP_COUNT_SENT:=
    TOTL_NSP_CHAR_READ:=TOTL_NSP_COUNT_READ:= 0;
    NSPINFO;
    IF NSP_DISPLAY THEN ACTION := ACT_QUITV;
   END;
 $
END OF PROCEDURE NSP;
%***********************************************************************
%       O U T E R      B L O C K                                       %
%***********************************************************************
ON ANYFAULT, PROGRAMDUMP(ARRAYS);
DO
 IF NOT HANDLE_INPUT(CURRENT_STATE) THEN
    CASE ACTION OF
         BEGIN
         ACT_PROCV: PROCESSOR;
         ACT_DISKV: DISK;
         ACT_NSPV:  NSP;
         ACT_QUITV: WRITE(REM,&lt;&quot;Bye Bye...&quot;&gt;);
         ELSE: ;    % Restart
         END
   ELSE
    ERR(&quot;Invalid Input&quot;)
UNTIL ACTION = ACT_QUITV;
END.
</code></pre>

<h2 id="sharedlibrarysitesupport">Shared Library Sitesupport</h2>

<p>File: SYMBOL/SITESUPPORT</p>

<pre><code>BEGIN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#######################################################################
%       SYSTEM  - Systems Utilities (UT)
%       PHASE   - Site Management Support Library
%       NAME    - (COHOON) SYMBOL/SITESUPPORT ON USERS
%                 (COHOON) LIBRARY/SITESUPPORT ON USERS
%       DATE    - Jan 24, 1990
%       AUTHOR  - Don Cohoon
%       PURPOSE:        This library should contain Systems functions
%                       to be shared by more than one program.
% Procedure | Release | Date | Author | Description
% SEARCHMIX | 3.6.250 |111888| Cohoon | Return active titles and info
%#######################################################################
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%      SYSTEMSTATUS ERROR ROUTINE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
PROCEDURE SYSTEMERRORMESSAGE(ERR);
     VALUE ERR;
     REAL ERR;
     BEGIN
     EBCDIC ARRAY EBUF[0:79];
     DEFINE SERR = REPLACE EBUF BY
          &quot;## SYSTEMSTATUS ERROR: &quot;,ERR FOR * DIGITS,&quot; - &quot;, #;
     CASE ERR OF
          BEGIN
         1: SERR &quot;ZERO DIVIDE&quot;;
         2: SERR &quot;EXPONENT OVERFLOW&quot;;
         3: SERR &quot;EXPONENT UNDERFLOW&quot;;
         4: SERR &quot;INVALID INDEX&quot;;
         5: SERR &quot;INTEGER OVERFLOW&quot;;
         6: SERR &quot;INACTIVE QUEUE&quot;;
         7: SERR &quot;MEMORY PROTECT&quot;;
         8: SERR &quot;INVALID OPERATOR&quot;;
         9: SERR &quot;LOOP&quot;;
        10: SERR &quot;MEMORY PARITY&quot;;
        11: SERR &quot;SCAN PARITY&quot;;
        12: SERR &quot;INVALID ADDRESS&quot;;
        13: SERR &quot;STACK OVERFLOW&quot;;
        14: SERR &quot;STRING PROTECT&quot;;
        15: SERR &quot;PROGRAMMED OPERATOR&quot;;
        16: SERR &quot;BOTTOM OF STACK&quot;;
        17: SERR &quot;SEQUENCE ERROR&quot;;
        18: SERR &quot;INVALID PROGRAM WORD&quot;;
        19: SERR &quot;STACK UNDERFLOW&quot;;
        33: SERR &quot;INVALID MIX NUMBER&quot;;
        34: SERR &quot;INVALID UNIT NUMBER&quot;;
        35: SERR &quot;SEGMENTED ARRAY&quot;;
        36: SERR &quot;INVALID SUB-TYPE&quot;;
        37: SERR &quot;IO TRACE&quot;;
       100: SERR &quot;INCOMPLETE MIX SAMPLE&quot;;
       101: SERR &quot;MIX HAS MORE ENTRIES&quot;;
      ELSE: SERR &quot;??&quot;;
               END;
     DISPLAY(EBUF[*]);
     END;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%   PROCEDURE -   SEARCH_MIX
%%%%%   AUTHOR    -   Don Cohoon
%%%%%   PURPOSE   -   Return active mix to procedure RESULTS one
%%%%%                 entry at a time.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
INTEGER PROCEDURE SEARCH_MIX            % 0 = All mix entries found.
                 %----------%           % 1 = RESULTS exited call
                                        % 2 = SystemStatus error
        (BUFF,
         SCR,
         RESULTS);
         ARRAY BUFF,                    % System/Status array
               SCR[0];                  % Passed to RESULTS.
         INTEGER PROCEDURE RESULTS      % 0= Continue, 1= Exit
                 (ETITLE,               % Mix Title (left just, alpha)
                  EINFO,                % Mix Info  (see global defines)
                  SCR);                 % Used for saving info between
                                        % calls.
                 EBCDIC ARRAY ETITLE,
                              EINFO[0];
                 ARRAY SCR[0];
                 FORMAL;
BEGIN
ARRAY
        INFO[0:29];          % MIX INFORMATION
EBCDIC ARRAY
        ETITLE[0:255],       % TASK TITLE (Extended from 0:47 12-12-89)
        EINFO[0] = INFO[*];  % PASSED TO PROCEDURE
POINTER
        PSTD,                % POINTS TO STANDARD NAME
        PNAME;               % POINTS TO ETITLE
INTEGER
        L1,                  % INDEX INTO BUFF (START OF STACKINFO)
        L2,                  %   &quot;     &quot;   &quot;   (START OF TITLE)
        L3,                  %   &quot;     &quot;   &quot;   (START OF JOBINFO)
        L4;                  %   &quot;     &quot;   &quot;   (SPECIFIC MIX INFO)
BOOLEAN
        FOUNDIT,             % TRUE when results stops SystemStatus loop
        SSERR;               % SystemStatus error word
DEFINE
        SYSTEMSTATUSERRORV = 2#, % SearchMix SystemStatus error returned
        SSERRF    = [11:8]#, % SystemStatus error field
        CLEAR(X)  = REPLACE X BY &quot; &quot; FOR SIZE(X) #,
        WCLEAR(X) = REPLACE X BY &quot; &quot; FOR SIZE(X) WORDS #,
        MIXNUMBER = BUFF[L1+1]#,
        SERIAL    = BUFF[L1+2]#,
        PRIORITY  = BUFF[L1+3]#,
        STACKSTATE= BUFF[L1+4]#,
        REPLY     = BUFF[L1+5]#,
        USAGE     = BUFF[L1+6]#,
        NAME_SIZE = (IF BUFF[L2-1] = 1 THEN BUFF[L2]
                       ELSE BUFF[L2-1])#,
        TASK_NAME = (IF BUFF[L2-1] = 1 THEN BUFF[L2+1]
                       ELSE BUFF[L2])#,
        JOBINFO   = BUFF[L4]#,
        STACKSTATUS = BUFF[L4+1]#, % Only valid if STACKSTATE &gt; 5
        COMPILERINFO = BUFF[L3+2]#,
        PROCESSTIME  = BUFF[L3+4]#, % Total CPU time (2.4ms)
        READYTIME    = BUFF[L3+5]#, % Total READYQ time (2.4ms)
        IOTIME       = BUFF[L3+7]#, % Total I/O time (2.4ms)
        COREINUSE    = BUFF[L3+13]#,% D2 Total (words)
        D1COREINUSE  = BUFF[L3+17]#,% D1 Total (words)
        STACKINFO    = BUFF[L3+15]#,% MCP info bits.
        END_OF_SS9      = #;
%-----------------------------------------------------------------------
PNAME := ETITLE[0];
IF NOT (SSERR := SYSTEMSTATUS(BUFF,9,0)) THEN
   BEGIN
     WHILE BUFF[1] ISNT 0 DO % Extend results array
      BEGIN
        RESIZE(BUFF,SIZE(BUFF)+120,RETAIN); % 60 Words per Mix entry
        SYSTEMSTATUS(BUFF,9,0);
      END;
        L1 := 2;
        DO BEGIN
                L3 := L1 + BUFF[L1];
                L2 := L1 + 7 + BUFF[L1 + 7];
                L4 := L2 + BUFF[L2];
                IF MIXNUMBER NEQ 0
                   THEN
                      BEGIN
                          CLEAR(ETITLE);
                          PSTD := POINTER(BUFF[L2+1]);
                          STANDARDTODISPLAY(PSTD,PNAME);
                          PNAME := ETITLE[0];
                          INFO[INFO_MIXNUMBERV] := MIXNUMBER;
                          INFO[INFO_SERIALV] := SERIAL;
                          INFO[INFO_PRIORITYV] := PRIORITY;
                          INFO[INFO_STACKSTATEV] := STACKSTATE;
                          INFO[INFO_REPLYV] := REPLY;
                          INFO[INFO_USAGEV] := USAGE;
                          INFO[INFO_JOBINFOV] := JOBINFO;
                          INFO[INFO_STACKSTATUSV] := STACKSTATUS;
                          INFO[INFO_COMPILERINFOV] := COMPILERINFO;
                          INFO[INFO_PROCESSTIMEV] := PROCESSTIME;
                          INFO[INFO_READYTIMEV] := READYTIME;
                          INFO[INFO_IOTIMEV] := IOTIME;
                          INFO[INFO_COREINUSEV] := COREINUSE;
                          INFO[INFO_STACKINFOV] := STACKINFO;
                          INFO[INFO_D1COREINUSEV] := D1COREINUSE;
                          FOUNDIT := RESULTS (ETITLE,EINFO,SCR) NEQ 0;
                      END;
                L1 := L3 + BUFF[L3];
           END UNTIL FOUNDIT OR L1 GEQ BUFF[0];
      SEARCH_MIX := REAL(FOUNDIT.[0:1]);
   END
    ELSE
     BEGIN
     SYSTEMERRORMESSAGE(REAL(SSERR).SSERRF);
     SEARCH_MIX := SYSTEMSTATUSERRORV;
     END;
SEARCH_MIX := REAL(FOUNDIT.[0:1]);
END OF S E A R C H M I X;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
EXPORT
        SEARCH_MIX           AS &quot;SEARCH_MIX&quot;;
FREEZE(TEMPORARY);
END.
</code></pre>

<hr />

<pre><code>____          
|  _ \  ___  _ __  
| | | |/ _ \| '_ \ 
| |_| | (_) | | | |
|____/ \___/|_| |_|                             

¯\_(ツ)_/¯
</code></pre>

<hr>

<h4 id="madeforhumansbyahuman">Made for Humans, by a Human</h4>

<h4 id="links">Links</h4>

<ul>
<li><a href="https://lwn.net/">Linux Weekly News</a></li>
<li><a href="https://fullcirclemagazine.org/">Full Circle Magazine</a></li>
<li><a href="https://www.linuxjournal.com/">Linux Journal</a></li>
<li><a href="https://www.linux-magazine.com/">Linux Magazine</a></li>
<li><a href="https://www.thefarside.com/">The Far Side</a></li>
</ul>

<h4 id="social">Social</h4>

<ul>
<li><a href="https://fosstodon.org/@Cohoon">Feedback</a></li>
<li><a href="/linux-in-house/feed-linux.rss">Linux RSS Feed</a></li>
<li><a href="/linux-in-house/feed-writing.rss">Writing RSS Feed</a></li>
<li><a href="https://linux-in-the-house.pages.dev/">Book</a></li>
</ul>

<div style="overflow-x:auto;">
<table style="width: 100%;">
<tr>
     <td>
<small><a href="/linux-in-house/linux/intro.html#createdwith">Created with</a></small>
     </td>
     <td>
<small>License: <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a></<small>
     </td>
     <td>

<p><small>linux-in-house Version: 4.186 </small></p>

<p></tr>
</table></p>

</div>


</body>
</html>

